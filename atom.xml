<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小菜鸟大成长</title>
  <subtitle>我喜欢忙忙碌碌的感觉，这样我才能感觉自己活着</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kaisai1994.com/"/>
  <updated>2016-06-06T07:40:31.728Z</updated>
  <id>http://kaisai1994.com/</id>
  
  <author>
    <name>kaisai1994</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android像素转换</title>
    <link href="http://kaisai1994.com//blog/2016/06/Android%E5%83%8F%E7%B4%A0%E8%BD%AC%E6%8D%A2.html"/>
    <id>http://kaisai1994.com//blog/2016/06/Android像素转换.html</id>
    <published>2016-06-06T07:25:01.259Z</published>
    <updated>2016-06-06T07:40:31.728Z</updated>
    
    <content type="html">&lt;p&gt;在Android中，1pt大概等于2.22sp以上仅供参考。&lt;br&gt;与分辨率无关的度量单位可以解决这一问题。Android支持下列所有单位:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;px(像素):屏幕上的点
in(英寸):长度单位
mm(毫米):长度单位
pt(磅):1/72英寸
dp(与密度无关的像素):一种基于屏幕密度的抽象单位。每英寸160点的显示器上1dp = 1px.
dip:与dp相同，多用于android/onphone示例中。
sp(与刻度无关的像素):与dp类似，但是可以根据用户的字体大小首选项进行缩放
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分辨率：整个屏是多少点，比如800x480&lt;br&gt;它是对于软件来说的显示，它是对于软件来说的显示单位，以px为单位的点。density（密度）值，表示每英寸有多少个显示点，与分辨率是两个概念，apk的资源包中，&lt;br&gt;当屏幕density = 240时使用hdpi标签的资源&lt;br&gt;当屏幕density = 160时使用mdpi标签的资源&lt;br&gt;当屏幕density = 120时使用ldpi标签的资源&lt;br&gt;一般android设置长度和宽度多用dip，设置字体大小多用sp，在屏幕密度为160&lt;br&gt;1dp = 1px = 1dip，1pt = 160/72sp&lt;br&gt;1pt = 1/72英寸，当屏幕密度为240时1dp = 1dip = 1.5px&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Android中，1pt大概等于2.22sp以上仅供参考。&lt;br&gt;与分辨率无关的度量单位可以解决这一问题。Android支持下列所有单位:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;px(像素):屏幕上的点
in(英寸):长度单位
mm(毫米):长度单位
pt(磅):1/72英寸
d
    
    </summary>
    
      <category term="Android" scheme="http://kaisai1994.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaisai1994.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java中的四种引用</title>
    <link href="http://kaisai1994.com//blog/2016/06/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8.html"/>
    <id>http://kaisai1994.com//blog/2016/06/Java中的四种引用.html</id>
    <published>2016-06-03T00:44:18.412Z</published>
    <updated>2016-06-03T01:03:39.542Z</updated>
    
    <content type="html">&lt;p&gt;再JDK2.1之后Java的引用分为以下四种:&lt;/p&gt;
&lt;h1 id=&quot;强引用（StrongReference&quot;&gt;&lt;a href=&quot;#强引用（StrongReference&quot; class=&quot;headerlink&quot; title=&quot;强引用（StrongReference)&quot;&gt;&lt;/a&gt;强引用（StrongReference)&lt;/h1&gt;&lt;p&gt;强引用是最普遍的引用，当一个对象具有强引用，那么垃圾回收器绝对不会回收他。&lt;br&gt;当内存空间不足，Java虚拟机宁可跑出OOM异常的错误，让程序终止也不会随意回收有强引用的对象来解决内存不足的问题。ex:A a = new A();强引用&lt;/p&gt;
&lt;h1 id=&quot;软引用&quot;&gt;&lt;a href=&quot;#软引用&quot; class=&quot;headerlink&quot; title=&quot;软引用&quot;&gt;&lt;/a&gt;软引用&lt;/h1&gt;&lt;p&gt;如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收他，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收塔，该对象就可以被程序使用，软引用可以用来实现内存敏感的高速缓存&lt;/p&gt;
&lt;h1 id=&quot;弱引用&quot;&gt;&lt;a href=&quot;#弱引用&quot; class=&quot;headerlink&quot; title=&quot;弱引用&quot;&gt;&lt;/a&gt;弱引用&lt;/h1&gt;&lt;p&gt;弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，而垃圾回收期线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收他的内存，不过垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。&lt;/p&gt;
&lt;h1 id=&quot;虚引用&quot;&gt;&lt;a href=&quot;#虚引用&quot; class=&quot;headerlink&quot; title=&quot;虚引用&quot;&gt;&lt;/a&gt;虚引用&lt;/h1&gt;&lt;p&gt;虚引用顾名思义就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，任何时候都可以被垃圾回收器回收。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;再JDK2.1之后Java的引用分为以下四种:&lt;/p&gt;
&lt;h1 id=&quot;强引用（StrongReference&quot;&gt;&lt;a href=&quot;#强引用（StrongReference&quot; class=&quot;headerlink&quot; title=&quot;强引用（StrongReference)&quot;&gt;&lt;
    
    </summary>
    
      <category term="Java" scheme="http://kaisai1994.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kaisai1994.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题目练习</title>
    <link href="http://kaisai1994.com//blog/2016/06/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E8%81%94%E7%B3%BB.html"/>
    <id>http://kaisai1994.com//blog/2016/06/剑指offer题目联系.html</id>
    <published>2016-06-02T12:13:44.809Z</published>
    <updated>2016-06-02T12:41:11.659Z</updated>
    
    <content type="html">&lt;h1 id=&quot;题目1-二叉树的深度&quot;&gt;&lt;a href=&quot;#题目1-二叉树的深度&quot; class=&quot;headerlink&quot; title=&quot;题目1 二叉树的深度&quot;&gt;&lt;/a&gt;题目1 二叉树的深度&lt;/h1&gt;&lt;p&gt;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。&lt;br&gt;解答:用递归的方法从根节点左右孩子出发一直遍历直到叶子节点&lt;br&gt;&amp;lt;–!more–&amp;gt;&lt;br&gt;    public class Solution {&lt;br&gt;    public int TreeDepth(TreeNode pRoot)&lt;br&gt;    {&lt;br&gt;        if(pRoot == null) return 0;&lt;br&gt;        else{&lt;br&gt;            if(TreeDepth(pRoot.left) &amp;gt; TreeDepth(pRoot.right))&lt;br&gt;            {&lt;br&gt;                return TreeDepth(pRoot.left) + 1;&lt;br&gt;            }&lt;br&gt;            else{&lt;br&gt;                return TreeDepth(pRoot.right) + 1;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;      }&lt;br&gt;    }&lt;/p&gt;
&lt;h1 id=&quot;题目2-不用加减乘除做加法&quot;&gt;&lt;a href=&quot;#题目2-不用加减乘除做加法&quot; class=&quot;headerlink&quot; title=&quot;题目2 不用加减乘除做加法&quot;&gt;&lt;/a&gt;题目2 不用加减乘除做加法&lt;/h1&gt;&lt;p&gt;题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;br&gt;解答：这个题目考查异或运算，但是偶然看到一位神用Java BigInteger.add做出来让我吐血三升，还有这样的方法，这里来实现一下用异或来写的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   public class Solution {
    public int Add(int num1,int num2) {
        while (num2!=0) {
            int temp = num1^num2;
            num2 = (num1&amp;amp;num2)&amp;lt;&amp;lt;1;
            num1 = temp;
        }
        return num1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;首先看十进制是如何做的： 5+7=12，三步走&lt;br&gt;第一步：相加各位的值，不算进位，得到2。&lt;br&gt;第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。&lt;br&gt;第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。&lt;br&gt;同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。&lt;br&gt;第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;amp;111)&amp;lt;&amp;lt;1。&lt;/p&gt;
&lt;p&gt;第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;amp;1010)&amp;lt;&amp;lt;1。&lt;br&gt;继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目1-二叉树的深度&quot;&gt;&lt;a href=&quot;#题目1-二叉树的深度&quot; class=&quot;headerlink&quot; title=&quot;题目1 二叉树的深度&quot;&gt;&lt;/a&gt;题目1 二叉树的深度&lt;/h1&gt;&lt;p&gt;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）
    
    </summary>
    
    
      <category term="算法" scheme="http://kaisai1994.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指Offer" scheme="http://kaisai1994.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Android面试经验总结</title>
    <link href="http://kaisai1994.com//blog/2016/06/Android%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93.html"/>
    <id>http://kaisai1994.com//blog/2016/06/Android面试经验总结.html</id>
    <published>2016-06-02T08:35:09.100Z</published>
    <updated>2016-06-02T08:45:33.266Z</updated>
    
    <content type="html">&lt;p&gt;最近常混迹一些论坛还有一些讨论组，发现很多好心人发了很多自己的面试经验，我自己觉得是一次很好的总结，所以把各个人的面试经验提到的问题又总结了一下，发现面试技术很多都注意基础，还有一些都是经常会被考到的技术点，自己总结出来一份也帮助自己好好准备面试。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;百度&quot;&gt;&lt;a href=&quot;#百度&quot; class=&quot;headerlink&quot; title=&quot;百度&quot;&gt;&lt;/a&gt;百度&lt;/h1&gt;&lt;h4 id=&quot;网络技术&quot;&gt;&lt;a href=&quot;#网络技术&quot; class=&quot;headerlink&quot; title=&quot;网络技术&quot;&gt;&lt;/a&gt;网络技术&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;TCP和UDP的区别&lt;/li&gt;
&lt;li&gt;TCP如何保证可靠传输&lt;/li&gt;
&lt;li&gt;HTTP的报文格式&lt;/li&gt;
&lt;li&gt;HTTP的头部包含哪些内容&lt;/li&gt;
&lt;li&gt;cookie实在头部还是数据段，为什么&lt;/li&gt;
&lt;li&gt;HTTP回复的状态吗和你知道哪些&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Java面向对象&quot;&gt;&lt;a href=&quot;#Java面向对象&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象:&quot;&gt;&lt;/a&gt;Java面向对象:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;Java多线程的实现及同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;线程和进程的区别&lt;/li&gt;
&lt;li&gt;操作系统如何实现多线程的调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;软件工程&quot;&gt;&lt;a href=&quot;#软件工程&quot; class=&quot;headerlink&quot; title=&quot;软件工程&quot;&gt;&lt;/a&gt;软件工程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;开发的瀑布模型&lt;/li&gt;
&lt;li&gt;开发软件项目的历程&lt;/li&gt;
&lt;li&gt;系统设计和详细设计的区别，类图在哪个阶段画的&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;如何做到覆盖测试，覆盖到每个分支&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Android&quot;&gt;&lt;a href=&quot;#Android&quot; class=&quot;headerlink&quot; title=&quot;Android&quot;&gt;&lt;/a&gt;Android&lt;/h4&gt;&lt;p&gt;区别2.X 3.X 4.X&lt;/p&gt;
&lt;h1 id=&quot;蘑菇街&quot;&gt;&lt;a href=&quot;#蘑菇街&quot; class=&quot;headerlink&quot; title=&quot;蘑菇街&quot;&gt;&lt;/a&gt;蘑菇街&lt;/h1&gt;&lt;h4 id=&quot;Android-1&quot;&gt;&lt;a href=&quot;#Android-1&quot; class=&quot;headerlink&quot; title=&quot;Android&quot;&gt;&lt;/a&gt;Android&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;touch event的事件传递机制&lt;/li&gt;
&lt;li&gt;activity四种启动模式&lt;/li&gt;
&lt;li&gt;常见设计模式和使用情况&lt;/li&gt;
&lt;li&gt;获取一个button的高度&lt;/li&gt;
&lt;li&gt;自定义View的流程&lt;/li&gt;
&lt;li&gt;内存泄漏&lt;/li&gt;
&lt;li&gt;thread的start和run方法有什么区别，开启一个线程必须调用start方法么&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;网易&quot;&gt;&lt;a href=&quot;#网易&quot; class=&quot;headerlink&quot; title=&quot;网易&quot;&gt;&lt;/a&gt;网易&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;APP怎么防止被强杀，怎么做到多进程&lt;/li&gt;
&lt;li&gt;Retrofit的优点和好处 MD的控件&lt;/li&gt;
&lt;li&gt;消息机制&lt;/li&gt;
&lt;li&gt;布局优化 merge include viewstub&lt;/li&gt;
&lt;li&gt;android中有哪些动画，View动画与属性动画的区别&lt;/li&gt;
&lt;li&gt;android网络优化&lt;/li&gt;
&lt;li&gt;自定义view的过程 三个测量模式，怎样从onMesure的两个参数中获取长度&lt;/li&gt;
&lt;li&gt;事件分发机制&lt;/li&gt;
&lt;li&gt;ListView 加载网络图片，怎样防止图片错乱&lt;/li&gt;
&lt;li&gt;java中的四种引用&lt;/li&gt;
&lt;li&gt;类加载器，双亲委托&lt;/li&gt;
&lt;li&gt;http和https的区别 RSA是什么，数字签名&lt;/li&gt;
&lt;li&gt;dp与px的转换公式，为什么用dp&lt;/li&gt;
&lt;li&gt;打包签名流程&lt;/li&gt;
&lt;li&gt;一键结束全部程序，activity会不调用onstop ondestory被强杀怎么恢复数据&lt;/li&gt;
&lt;li&gt;ANR几秒&lt;/li&gt;
&lt;li&gt;快排 时间复杂度 O（n2）是怎样的情况&lt;/li&gt;
&lt;li&gt;volatile和synchronized的区别，锁有哪些，static和synchd修饰的方法是什么锁，两个线程同时i++会怎么样还有线程池&lt;/li&gt;
&lt;li&gt;AsyncTask &lt;/li&gt;
&lt;li&gt;有个线程跑完后会显示textview文字，但是没跑完就按返回会发生什么&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;蘑菇街Android开发&quot;&gt;&lt;a href=&quot;#蘑菇街Android开发&quot; class=&quot;headerlink&quot; title=&quot;蘑菇街Android开发&quot;&gt;&lt;/a&gt;蘑菇街Android开发&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Git做代码托管，rebase，fetch和pull&lt;/li&gt;
&lt;li&gt;Java虚函数&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;Java反射，类加载的Class怎么调用类的所有属性和方法&lt;/li&gt;
&lt;li&gt;Android中的几种Context有什么区别&lt;/li&gt;
&lt;li&gt;Android内存泄漏&lt;/li&gt;
&lt;li&gt;bitmap复用&lt;/li&gt;
&lt;li&gt;OOM&lt;/li&gt;
&lt;li&gt;外观模式&lt;/li&gt;
&lt;li&gt;FrameWork源码&lt;/li&gt;
&lt;li&gt;自定义控件&lt;/li&gt;
&lt;li&gt;Android动态加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;蘑菇街-1&quot;&gt;&lt;a href=&quot;#蘑菇街-1&quot; class=&quot;headerlink&quot; title=&quot;蘑菇街&quot;&gt;&lt;/a&gt;蘑菇街&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Android四大组件&lt;/li&gt;
&lt;li&gt;Android生命周期onpause和onstop&lt;/li&gt;
&lt;li&gt;Fragment是否看过源码&lt;/li&gt;
&lt;li&gt;Service有哪几种&lt;/li&gt;
&lt;li&gt;隐式启动和显式启动&lt;/li&gt;
&lt;li&gt;Service两种启动方式&lt;/li&gt;
&lt;li&gt;启动线程方式有哪几种&lt;/li&gt;
&lt;li&gt;handle消息队列相关&lt;/li&gt;
&lt;li&gt;几种常见布局， 布局group树过程&lt;/li&gt;
&lt;li&gt;weight属性&lt;/li&gt;
&lt;li&gt;布局优化相关&lt;/li&gt;
&lt;li&gt;ArraylistLinklist&lt;/li&gt;
&lt;li&gt;线程进程区别&lt;/li&gt;
&lt;li&gt;一个app能否是多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;360&quot;&gt;&lt;a href=&quot;#360&quot; class=&quot;headerlink&quot; title=&quot;360&quot;&gt;&lt;/a&gt;360&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;网络框架实现，volley原理&lt;/li&gt;
&lt;li&gt;线程池原理，java线程池&lt;/li&gt;
&lt;li&gt;一个activity只能有一个进程么&lt;/li&gt;
&lt;li&gt;activity任务栈，启动模式&lt;/li&gt;
&lt;li&gt;夜间主题&lt;/li&gt;
&lt;li&gt;动态加载原理，classloader&lt;/li&gt;
&lt;li&gt;listview实现左滑&lt;/li&gt;
&lt;li&gt;view的事件分发与渲染流程&lt;/li&gt;
&lt;li&gt;LruCache的理解原理以及哪些方式实现缓存调度&lt;/li&gt;
&lt;li&gt;GC原理，实现方式，能否手动控制GC回收&lt;/li&gt;
&lt;li&gt;OOM内存泄漏的问题&lt;/li&gt;
&lt;li&gt;mvp与mvc区别，实现原理&lt;/li&gt;
&lt;li&gt;volley原理，发送五个请求&lt;/li&gt;
&lt;li&gt;图片缓存技术的实现&lt;/li&gt;
&lt;li&gt;listview原理，adpter与view如何绑定的，如何自己设计一个类似listview的自定义view，子item复用，管理以及getview实现&lt;/li&gt;
&lt;li&gt;进程实现方式&lt;/li&gt;
&lt;li&gt;asynctask&lt;/li&gt;
&lt;li&gt;CG原理&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;网易-1&quot;&gt;&lt;a href=&quot;#网易-1&quot; class=&quot;headerlink&quot; title=&quot;网易&quot;&gt;&lt;/a&gt;网易&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;推送。长连接 心跳连接&lt;/li&gt;
&lt;li&gt;LTE协议栈项目&lt;/li&gt;
&lt;li&gt;项目开源框架的源码分析&lt;/li&gt;
&lt;li&gt;加密算法&lt;/li&gt;
&lt;li&gt;消息处理机制&lt;/li&gt;
&lt;li&gt;asynctask&lt;/li&gt;
&lt;li&gt;android卡顿优化&lt;/li&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;li&gt;属性动画&lt;/li&gt;
&lt;li&gt;touch事件分发机制&lt;/li&gt;
&lt;li&gt;android开机过程&lt;/li&gt;
&lt;li&gt;Service与Thread的区别&lt;/li&gt;
&lt;li&gt;SQLite并发读取或者写入&lt;/li&gt;
&lt;li&gt;线程与进程&lt;/li&gt;
&lt;li&gt;Activity与Service的通信问题&lt;/li&gt;
&lt;li&gt;Activity与Fragment的生命周期&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;腾讯-amp-阿里&quot;&gt;&lt;a href=&quot;#腾讯-amp-阿里&quot; class=&quot;headerlink&quot; title=&quot;腾讯 &amp;amp; 阿里&quot;&gt;&lt;/a&gt;腾讯 &amp;amp; 阿里&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;volley原理&lt;/li&gt;
&lt;li&gt;403是什么意思&lt;/li&gt;
&lt;li&gt;TCP如何实现可靠传输&lt;/li&gt;
&lt;li&gt;线程进程的区别&lt;/li&gt;
&lt;li&gt;调度算法&lt;/li&gt;
&lt;li&gt;快排&lt;/li&gt;
&lt;li&gt;handle looper MessageQueen&lt;/li&gt;
&lt;li&gt;UIL和picasso的区别，底层实现&lt;/li&gt;
&lt;li&gt;java四种引用&lt;/li&gt;
&lt;li&gt;IPC几种通信方式&lt;/li&gt;
&lt;li&gt;static加在方法上有什么特殊的含义&lt;/li&gt;
&lt;li&gt;hashmap的原理&lt;/li&gt;
&lt;li&gt;String StringBuilder StringBuffer&lt;/li&gt;
&lt;li&gt;LRU&lt;/li&gt;
&lt;li&gt;IPC几种通信方式&lt;/li&gt;
&lt;li&gt;ListView 和RecycleView&lt;/li&gt;
&lt;li&gt;ActionBar和Toolbar&lt;/li&gt;
&lt;li&gt;重写View&lt;/li&gt;
&lt;li&gt;Volley&lt;/li&gt;
&lt;li&gt;UIL的原理&lt;/li&gt;
&lt;li&gt;zygote死掉后会重新启动&lt;/li&gt;
&lt;li&gt;zygote和systemservice&lt;/li&gt;
&lt;li&gt;Android系统为系统安全性做什么&lt;/li&gt;
&lt;li&gt;java基础知识&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近常混迹一些论坛还有一些讨论组，发现很多好心人发了很多自己的面试经验，我自己觉得是一次很好的总结，所以把各个人的面试经验提到的问题又总结了一下，发现面试技术很多都注意基础，还有一些都是经常会被考到的技术点，自己总结出来一份也帮助自己好好准备面试。&lt;br&gt;
    
    </summary>
    
      <category term="面试总结" scheme="http://kaisai1994.com/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试" scheme="http://kaisai1994.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO学习笔记总结</title>
    <link href="http://kaisai1994.com//blog/2016/05/JavaIO%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0.html"/>
    <id>http://kaisai1994.com//blog/2016/05/JavaIO学习总结笔记.html</id>
    <published>2016-05-31T02:56:36.555Z</published>
    <updated>2016-05-31T15:26:57.002Z</updated>
    
    <content type="html">&lt;p&gt;说道JavaIO流可能就要祭出这张图了，·&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/384764/2012031413373126.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;这张图很清楚的将IO流的体系划分了出来&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;流的概念和作用&quot;&gt;&lt;a href=&quot;#流的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;流的概念和作用&quot;&gt;&lt;/a&gt;流的概念和作用&lt;/h1&gt;&lt;p&gt;  流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 &lt;/p&gt;
&lt;h1 id=&quot;IO流的分类&quot;&gt;&lt;a href=&quot;#IO流的分类&quot; class=&quot;headerlink&quot; title=&quot;IO流的分类&quot;&gt;&lt;/a&gt;IO流的分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;根据处理数据类型的不同分为：字符流和字节流&lt;/li&gt;
&lt;li&gt;根据数据流向不同分为：输入流和输出流&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;字符流和字节流&quot;&gt;&lt;a href=&quot;#字符流和字节流&quot; class=&quot;headerlink&quot; title=&quot;字符流和字节流&quot;&gt;&lt;/a&gt;字符流和字节流&lt;/h1&gt;&lt;p&gt;  字节流：处理字节数据的流对象。设备上的数据无论是图片或者dvd，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。&lt;br&gt;  那么为什么要有字符流呢？因为字符每个国家都不一样，所以涉及到了字符编码问题，那么GBK编码的中文用unicode编码解析是有问题的，所以需要获取中文字节数据的同时+ 指定的编码表才可以解析正确数据。为了方便于文字的解析，所以将字节流和编码表封装成对象，这个对象就是字符流。只要操作字符数据，优先考虑使用字符流体系。&lt;br&gt;  注意：流的操作只有两种：读和写。&lt;br&gt;  流的体系因为功能不同，但是有共性内容，不断抽取，形成继承体系。该体系一共有四个基类，而且都是抽象类。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;字节流：InputStream  OutputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;字符流：Reader  Writer&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;说道JavaIO流可能就要祭出这张图了，·&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/384764/2012031413373126.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;这张图很清楚的将IO流的体系划分了出来&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kaisai1994.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kaisai1994.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之排序</title>
    <link href="http://kaisai1994.com//blog/2016/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F.html"/>
    <id>http://kaisai1994.com//blog/2016/05/数据结构与算法之排序.html</id>
    <published>2016-05-30T13:53:44.269Z</published>
    <updated>2016-05-30T14:34:40.019Z</updated>
    
    <content type="html">&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;  冒泡排序是通过两辆相邻互换的方式每一轮对比出一个最大或者最小值，好比一群个头大小不同的人排队，个子高的人不停与身边相邻的人对比，然后互换位置，冒泡排序大致就是这个原理。&lt;br&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201209/07/1347009396_8149.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BubbleSort {
  public bubbleSort(){
  inta[]= {49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99, 98,54,56,17,18,23,34,15,35,25,53,51};
  int temp=0;
  for(int i=0;i&amp;lt;a.length-1;i++){  //N个数至少要交换N-1轮
   for(int j=0;j&amp;lt;a.length-1-i;j++){ //每一轮都有一个数沉底，所以当进行到N轮就有N个数沉底要减去i
     if(a[j]&amp;gt;a[j+1]){
       temp=a[j];
       a[j]=a[j+1];
       a[j+1]=temp;
     }
   }
}
for(int i=0;i&amp;lt;a.length;i++){
   System.out.println(a[i]); 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;快速排序——最常用的排序&quot;&gt;&lt;a href=&quot;#快速排序——最常用的排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序——最常用的排序&quot;&gt;&lt;/a&gt;快速排序——最常用的排序&lt;/h1&gt;&lt;p&gt;  快速排序是基于一种二分的思想，从序列的两端开始探索扫描，找准一个基准数，从左往右找大于它的数，再从右往左进行扫描找小于它的数，然后做交换。&lt;/p&gt;
&lt;p&gt;代码实现:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void quickSort(int[] a,int left,int right)
{
    int i,j,t,tmp;
    if(left &amp;gt; right)
    {
        return;
    }
    tmp = a[left];//基准数
    i = left;
    j = right;
    while(i != j)
    {
        //先从右边开始查找，右边的要大于基准数
        while(a[j] &amp;gt;= tmp &amp;amp;&amp;amp; i &amp;lt; j)
        {    
            j--
        }
        while(a[i] &amp;lt;= tmp &amp;amp;&amp;amp; i &amp;lt; j)
        {
            i++;
        }
        if（i &amp;lt; j)
        {
            t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    a[left] = a[i];
    a[i] = tmp;

    quickSort(left,i - 1);
    quickSort(i + 1,right);
} 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;  冒泡排序是通过两辆相邻互换的方式每一轮对比出一个最大或者最小值，好比一群个头大小不同的人排队，个子高的人不停与身边相邻的人对比，然后互换位置，冒泡排序大致就是这个原理。&lt;br&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201209/07/1347009396_8149.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://kaisai1994.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://kaisai1994.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://kaisai1994.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基于Github利用Hexo搭建一个专属博客</title>
    <link href="http://kaisai1994.com//blog/2016/05/%E5%9F%BA%E4%BA%8EGithub%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2.html"/>
    <id>http://kaisai1994.com//blog/2016/05/基于Github利用Hexo搭建一个专属博客.html</id>
    <published>2016-05-26T14:44:21.915Z</published>
    <updated>2016-05-27T16:05:56.728Z</updated>
    
    <content type="html">&lt;p&gt;通过本次教程你可以一步一步的搭建一个属于你自己的博客，我们需要的技术有Github和Hexo的配置，只需短短的几十分钟，你就可以搭建一个属于自己的博客了&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;建立一个Github&quot;&gt;&lt;a href=&quot;#建立一个Github&quot; class=&quot;headerlink&quot; title=&quot;建立一个Github&quot;&gt;&lt;/a&gt;建立一个Github&lt;/h1&gt;&lt;p&gt;  首先使用你的github创建一个仓库，仓库名必须为：你的用户名.github.io，这样创建的仓库有自己的项目页面，这样你使用Hexo搭建的博客才能被访问到，起初进行到这步骤的时候我有些疑惑，因为以前听说过使用github page去搭建一个博客，需要创建一个分支提交才会将页面生成，后来才明白这是两件事，&lt;br&gt;  在github上当你使用以上的仓库名时，github就会默认给你生成一个&lt;strong&gt;项目页面&lt;/strong&gt;他和&lt;strong&gt;github page&lt;/strong&gt;页面不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以知道了这个原理，希望你不要把自己的github仓库名改变~乖乖的改成我说的格式撒~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立好一个仓库之后，先放着，接下来搭建本地环境&lt;/p&gt;
&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;首先我们创建一个文件夹并进入，在git bash下运行以下命令，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完毕后，在git bash中输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们需要安装一些Hexo插件，建议大家都安装上，可以生成sitemap，RSS，部署到git。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-generator-index --save
npm install hexo-generator-archive --save
npm install hexo-generator-category --save
npm install hexo-generator-tag --save
npm install hexo-server --save
npm install hexo-deployer-git --save
npm install hexo-deployer-heroku --save
npm install hexo-deployer-rsync --save
npm install hexo-deployer-openshift --save
npm install hexo-renderer-marked@0.2 --save
npm install hexo-renderer-stylus@0.2 --save
npm install hexo-generator-feed@1 --save
npm install hexo-generator-sitemap@1 --save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上这些创建好了之后几个一个框架就搭建完毕了，你可以通过以下两个命令进行构建和发布&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate 
hexo server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完以上两个命令你就可以在浏览器地址栏输入&lt;a href=&quot;http://localhost:4000可以看到hexo的&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000可以看到hexo的&lt;/a&gt;&lt;br&gt;博客大框已经搭建好了，但是和我们看到的精美博客不同。其实这只是一个小起步。&lt;/p&gt;
&lt;h1 id=&quot;Hexo大换脸—————使用主题next&quot;&gt;&lt;a href=&quot;#Hexo大换脸—————使用主题next&quot; class=&quot;headerlink&quot; title=&quot;Hexo大换脸—————使用主题next&quot;&gt;&lt;/a&gt;Hexo大换脸—————使用主题next&lt;/h1&gt;&lt;p&gt;关于主题的使用网络上有太多太多的博客都有介绍主题的使用配置了，其中最官方的还是&lt;br&gt;&lt;a href=&quot;http://theme-next.iissnan.com/getting-started.html&quot; title=&quot;Next官方文档&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://theme-next.iissnan.com/getting-started.html&lt;/a&gt;&lt;br&gt;动手能力还是要有的这里面介绍了很多，非常详细&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通过本次教程你可以一步一步的搭建一个属于你自己的博客，我们需要的技术有Github和Hexo的配置，只需短短的几十分钟，你就可以搭建一个属于自己的博客了&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://kaisai1994.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="搭建博客" scheme="http://kaisai1994.com/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
